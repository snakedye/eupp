# White Paper: Agnostic UTXO Payload Protocol (AUPP)

## 1. Abstract

The **Agnostic UTXO Payload Protocol (AUPP)** introduces a minimalist Layer 1 designed for secure data commitment rather than embedded currency logic. It decouples value from state by structuring every output as a triad of **Amount**, **Data Hash**, and a **Cryptographic Commitment**. This design reduces the blockchain's role to a pure verification and ordering engine, creating a robust foundation for off-chain protocols to anchor their state without imposing their logic on the consensus layer.

## 2. Transaction Architecture

AUPP utilizes a Unspent Transaction Output (UTXO) model where the state of the ledger is the set of all unspent outputs.

### 2.1 Input Structure

To spend an existing output, a transaction input must provide:

- **Version**: Protocol versioning.
- **Transaction ID (tx_id):** The hash of the previous transaction.
- **Output Index (out_idx):** The specific index in the previous transaction.
- **Public Key (pk):** The key used to satisfy the commitment.
- **Signature (sig):** Cryptographic proof of authorization over the new outputs.

### 2.2 Output Structure

Each output defines the "locked" state of the assets:

- **Amount (u64):** A 64-bit unsigned integer representing the fungible value.
- **Data Hash (H(data)):** A 32-byte hash of an agnostic payload.
- **Commitment (H(pk || H(data))):** A 32-byte hash that binds the spender's identity to the specific data hash.

Note: In the current implementation commitments are computed by hashing the public key bytes concatenated with the data hash using Blake2s256.

## 3. Cryptographic Security Model

The security of AUPP relies on a "Double-Binding" mechanism. A transaction is only valid if the spender proves they own the key associated with the commitment **and** authorizes the specific destination of the funds.

### 3.1 Commitment Verification

The spender must reveal their Public Key (pk). The network verifies that this key was the one intended by the original sender by checking:

```plaintext
create_commitment(pk, data_hash) == commitment
```

This ensures that the holder of a different key cannot spend the amount unless it is presented alongside the exact public key committed to in the previous output.

### 3.2 Signature Generation

The signature (sig) is generated using Ed25519 in the current implementation. The signature is computed over a "Sighash" that includes the context of the spend to prevent replay attacks:

```plaintext
sig = sign(sk, Hash(tx_id ∥ out_idx ∥ all_new_outputs))
```

The code computes the sighash with Blake2s256 in a deterministic byte order and verifies signatures with Ed25519 using the revealed public key in the input.

## 4. Verification Workflow

For a block to be accepted, nodes must validate every transaction against the following criteria:

1. **Commitment Match:** For every input, `create_commitment(pk, data_hash) == commitment`.
2. **Signature Validity:** The `sig` must be a valid Ed25519 signature.
3. **Conservation of Value:** `sum(outputs) <= sum(inputs)`.
4. **Reward Compliance:** If the transaction spends a Lead UTXO (Mining Tx), the output amount must not exceed the calculated limit:
   ```plaintext
   amount <= min(100000, 2^(difficulty/4))
   ```
5. **Data Integrity:** The `data_hash` remains cryptographically bound to the new outputs.

## 5. Mining Protocol: Chained Mask Proof-of-Work (CM-PoW)

AUPP integrates consensus directly into the UTXO set. Mining is defined as the act of successfully spending the **"Lead UTXO"** (index 0) of the previous block.

### 5.1 The Lead UTXO

Every block contains a special output at index 0. This output acts as the "Challenge" for the next block. It contains:
- **The Mask:** A 32-byte value stored in the `commitment` field. Miners interpret this as a 256-bit mask.
- **The Reward:** The `amount` field, which is generated by the network based on the mask difficulty.

### 5.2 The Mining Challenge

To "mine" the next block, a miner must generate a keypair where the Public Key (`pk`) satisfies the mask condition:

```plaintext
(mask & pk) == 0
```

Because the miner must spend the previous block's Lead UTXO to claim the reward, the chain is physically linked. It is impossible to work on Block N+1 without the finalized state of Block N.

### 5.3 Capped Incentive Curve

To prevent inflation while incentivizing security, AUPP utilizes a Capped Exponential Reward function. The reward is not fixed; it is dynamic based on the difficulty of the mask the miner chooses to solve:

```plaintext
R(D) = min(100000, 2^(floor(D/4)))
```

- **Spam Prevention:** Low-difficulty blocks (weak masks) yield negligible rewards, making spam attacks economically unviable.
- **The Hard Cap:** The reward ceilings at **100,000** units. This prevents hyper-inflation and establishes an economic equilibrium where miners are incentivized to maintain difficulty around the cap threshold (approx. 68 bits of difficulty).

### 5.4 Consensus Rule: Maximum Accumulated Supply (MAS)

To ensure the security of the ledger in a market-driven difficulty environment, AUPP discards the "Longest Chain" rule. Instead, the network follows the **Maximum Accumulated Supply (MAS)** rule.

The "canonical" chain is defined as the path from the Genesis block to a leaf block that contains the highest cumulative sum of all Lead UTXO rewards:

```plaintext
Weight_chain = sum(Reward(Block_i) for i in range(0, height))
```

This ensures that a single high-difficulty block—representing significant computational effort—cannot be overtaken by a long sequence of low-difficulty "spam" blocks, as the exponential nature of the reward function ensures that work and value are cryptographically linked.

## 6. Conclusion

By reducing the base layer to its absolute essentials—verification and ordering—AUPP provides a "dumb" but highly secure foundation for "smart" systems. Its rigid commitment structure, combined with a market-driven mining challenge, ensures that the ledger remains a neutral, auditable, and censorship-resistant arbiter of state. This minimalist design is not a limitation but a feature, offering a stable and predictable settlement layer upon which complex, high-throughput Layer 2 protocols can be built without compromising the integrity of the core ledger.
